# HTTP プロトコルまとめ

作成日 2019/01/29、更新日 2019/11/06

## 01. HTTP プロトコルとは

HTTP ... Hypertext Transfer Protocol

TCP の接続が完了すると、クライアント側から HTTP のファイル取得要求を送信する、サーバー側から応答を 1 つ返す

Web ページを構成する部品が多数ある場合、それらも全てこの手順を繰り返して取得する

Web ブラウザは複数の HTTP 通信（TCP コネクション）を開設して、同時に取得して、通信時間を短縮する

HTTP/1.1 以降の規格では、基本的にコネクションはずっとオープンしたままでデータのやりとりを行う

- HTTP/0.9 ... GET メソッドのみ
- HTTP/1.0 ... HEAD/POST メソッドが追加、ヘッダフィールドが整備、MIME タイプもサポート
- HTTP/1.1 ... PUT/DELETE/OPTIONS/CONNECT メソッドが追加
- HTTP/2.0 ... 2015 年制定

コマンドも応答もすべてテキスト形式なので、通信効率は悪いが人間には理解しやすい

## 02. HTTP メッセージの詳細

HTTP でサーバーとクライアントがやりとりする HTTP メッセージは、
基本的に「メッセージヘッダ + 空行(CR+LF) + メッセージボディ」という構造になっている。

リクエストヘッダの 1 行目は、リクエストラインとなる => 要求の書式

### 要求の書式

「メソッド名 ターゲット HTTP バージョン」

```text
GET /index.html HTTP/1.1
```

### 応答の書式

「HTTP バージョン ステータスコード 結果フレーズ」

```text
HTTP/1.1 200 OK
HTTP/1.1 301 Moved Permanently
HTTP/1.1 404 Not Found
```

### HTTP 要求

- GET ... 指定したリソースを取得
- HEAD ... ヘッダ情報だけ取得
- POST ... データを送信
- PUT ... データを送信して書き換え
- DELETE ... 削除
- CONNECT ... プロキシにおけるトンネリング処理
- OPTIONS ... 利用可能なメソッドの一覧を返す
- TRACE ... サーバーの動作を診断

### HTTP ステータスコード

- 1xx ... Informational
- 2xx ... Successful
- 3xx ... Redirection
- 4xx ... Client Error
- 5xx ... Server Error

## 03. HTTP プロトコルの補足

### ユーザー認証

- Basic 認証（基本認証） ... ユーザー名とパスワードを Base64 で符号化してから送信
- Digest 認証 ... サーバーからチャレンジ値を送信、それと合わせてハッシュ化した結果を送信
- フォームによる認証 ... HTTP プロトコルの一部にあらず

### HTTP の暗号化

HTTPS = HTTP over SSL/TLS

### HTTP の高速化

- HTT パーシステント接続
- パイプライン処理
- データレンジのサポート

### HTTP/2 の概要

- 送信データのバイナリフレーム化
- ヘッダフィールドのバイナリエンコーディング
- 多重ストリーム通信によるコネクション数の削減
- エラー処理の改善

このプロトコルを利用するためには HTTPS 接続が必要

## 04. HTTP の状態管理

HTTP は下位のトランスポート層のプロトコルとして TCP を使うことが多いが、SSL/TLS を用いて暗号化されて伝送されることもある。

HTTP そのものは複数回の通信をまたぐ状態の保存・管理を行わないステートレス型のシンプルなプロトコル

Cookie とよばれる拡張仕様で状態管理ができる

### クッキーとセッションについて

Cookie のやりとりはヘッダーを使う

```text
// サーバーからクライアントにCookieを送る
Set-Cookie: <cookie-name>=<cookie-value>

// クライアントからサーバーにCookieを送る
Cookie: <cookie-name>=<cookie-value>

// 有効期間の設定（日時指定と秒指定）
Set-Cookie: Id=0001;Expires=Mon, 1 Jan 2020 01:01:01 GMT;
Set-Cookie: Id=0p01;Max-Age=600;

// HTTPS通信でのみサーバーに送信される
Set-Cookie: Id=0001;Secure;

// JavaScriptのAPIでCookieにアクセスできなくする
SetCookie: Id=0001;HttpOnly;

// サブドメインで共有させる
Set-Cookie: Id=0001;Domain=sample.com;

// 設定した値をURLが含む場合にCookieを送信する
Set-Cookie: ID=0001;Path=/root;
```

- セッションクッキー ... Expires または Max-Age が指定されていない Cookie のこと。ブラウザを終了すれば削除される
- 永続クッキー ... Expires または Max-Age が指定された Cookie のこと

システムにログインすると、サーバーがセッション ID を発行し、Cookie に付与してクライアントに送信する。
以降、クライアントは Cookie にセッション ID を付加し、リクエストを送信することで
サーバーはどのクライアントからの通信であるかを判別する

## 05. Web サーバーの負荷を軽減するには

ロードバランサーを使う

- ラウンドロビン ... 分散対象の仮想サーバーに順番にアクセスを振り分ける
- リーストコネクション ... 最も少ないセッションの仮想サーバーにアクセスを振り分ける（セッションの保持を行っているサイトに有効）
- ソース IP ハッシング ... 送信元 IP アドレスごとにアクセスする仮想サーバーを振り分ける

## 06. Authorization ヘッダについて

### `Authorization: Bearer`の`Bearer`とは

- HTTP でトークンを利用した認証・認可をする手法として`RFC6750`がある
- `Authorization: auth-scheme (token68 / auth-params)`の形式で書くことと定められている
- `RFC7235`によれば、`auth-scheme`の取りうる値は IANA で管理されている
- `Bearer`はスキームとして登録済み

### Bearer スキームとは

- トークンは任意の token68 文字列とする
- クライアントは`Authorization: Bearer`トークンヘッダをリクエストに含めて送信する
- リクエストが要件を満たしていないとき、サーバは`WWW-Authenticate: Bearer`パラーメーターヘッダを返す

### token68 文字列とは

- 1 文字以上の ASCII アルファベット、 ASCII 数字、-、.、\_、 ~、+、/ の列
- また末尾に任意の個数の = があっても構わない

### Authorization ヘッダの詳細

HTTP の Authorization リクエストヘッダは、
ユーザーエージェントがサーバーから認証受けるための証明書を保持し、
ふつうはサーバーが 401 Unauthorized 状態と WWW-Authenticate ヘッダを返した後に使われる

ヘッダ構文 => `Authorization: <type> <credentials>`

- `<type>` ... 認証の種類、一般的には Basic
- `<credentials>` ... 認証情報

Basic 認証方式を採用している場合、認証情報は次のように構築される

- コロンで結合したユーザー名とパスワード => `aladin:opensesame`
- それを Base64 でエンコードする => `YWxhZGRpbjpvcGVuc2VzYW1l`

#### 認証の種類

- Basic ... base64 でエンコードされた認証情報
- Bearer ... OAuth2.0 で保護されたリソースにアクセスするベアラトークン
- Digest ... SHA 暗号化、Firefox では md5 ハッシュだけがサポートされる
- HOBA ... HTTP オリジン認証

などなど

### Base64 でエンコードするとは？

- Base64 エンコードは暗号化でもハッシュでもない
- この方法の安全性はクリアテキストで認証情報を送るのと同等
- Base64 は可逆エンコーディング
- Basic 認証は HTTPS との組み合わせで使用するべき

かつて SMTP では、ASCII といわれる 7bit の英数字しか送れなかった。

すべてのデータを英数字であらわす MIME という規格が登場し、
base64 というデータの変換方法が定められた。

MIME に乗っ取って、データをエンコード・デコードすることで、
メールを通して画像や音声などの送受信が可能になった。

現在でも、JSON などで特殊文字を含まないように画像データを
base64 でエンコードしたり、base64 でエンコードした画像を
html にそのまま埋め込んだりする

#### Base64 の処理の実際

base64 における処理は簡潔にいうと、
エンコードしたいファイルのバイナリデータを 6bit づつ取り出し
（足りない分は 0 を追加する）、
6bit と Ascii 文字の変換表を用いて、4 文字づつにする。
4 文字に満たない場合は、`=`を追加する

```text
変換したい文字列
"abcdefg"

16進数にする
0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67

2進数にする
0110 0001, 0110 0010, 0110 0011, 0110 0100, 0110 0101, 0110 0110, 0110 0111

6bitづつに分割する
011000, 010110, 001001, 100011, 011001, 000110, 010101, 100110, 011001, 11

最後の2ビットが余るので0を追加する
011000, 010110, 001001, 100011, 011001, 000110, 010101, 100110, 011001, 110000

ビットを文字に変換する
Y W J j Z G V m Z w

4文字づつに分割する
YWJj ZGVm Zw

最後が2文字足りないので=を追加する
YWJj ZGVm Zw==

完成
"YWJjZGVmZw=="
```

## 07. CORS (Cross Origin Resource Sharing) とは？

任意の Web ページから、別オリジン下に格納されている一部のリソースをアクセスする事は原則できないが、
この設定を行うとアクセスできるようになる

### CORS の設定方法

以下は HTTP レスポンスに対して行う

ヘッダー情報に `Access-Control-Allow-Origin: *` という 1 行を追加する

=> すべてのサイトから、リソースシェアリングを許す

ヘッダー情報に `Access-Control-Allow-Origin: http://foo.example` という 1 行を追加する

=> リソース所有者が `http://foo.example` からのアクセスだけを許す

- 最後のスラッシュはいらない
- おそらく 2 つ 3 つと続けて書けない
