# ローカルで実行する Pyhon スクリプトを作る

作成日 2019/12/04、更新日 2020/02/03

## 01. 直接実行したときだけスクリプトが動くようにする

### `__name__`変数とは

`apple.py` というファイルを作成し、`python apple.py` を実行する

```python
print (__name__)
# => __main__

print (__file__)
# => apple.py
```

-   結果が `__main__` になったのは、`apple.py` を直接実行したから
-   別ファイルから `import apple` していたら、結果は `apple` になる

この変数を利用して、直接実行したときだけ動くコードを書く

```python
def apple(name):
    print(f'hello {name}!')


if __name__ == "__main__":
    apple('world')
```

## 02. 引数を使う

```python
import sys

try:
    report_type = sys.argv[1]
except IndexError:
    print('Please input report_type')
    exit()

#　report_typeを何かに使う
```

## 03. データをローカルディスクに保存する

shelf を使う。shelve は shelf の複数形

```python
import shelve

# データを保存する
shelf = shelve.open(c.SHELF_FILE)
shelf['report_type'] = report_type
shelf.close()

# 保存したデータを読む
shelf = shelve.open(c.SHELF_FILE)
report_type = None
if 'report_type' in shelf:
    report_type = shelf['report_type']
shelf.close()

if report_type:
    #　report_typeを何かに使う
else:
    print('Error => no report_type')
    exit()
```

## 04. 外部コマンドを実行する

### subprocess.call()

`call()`メソッドを使うと、終了待ちをする。\
Python のプロセスは、ブロックされる

```python
import subprocess

cmd = 'sleep 30'
proc = subprocess.call(cmd, shell=True)
```

### subprocess.Popen()

`Popen()`メソッドを使うと、終了待ちをせずに、\
サブプロセスを起動したら、Python のプロセスは、先に進む。\
親プロセスの Python が、サブプロセスよりも先に終了してしまったら、\
孤児プロセスとして、root プロセスに引き取られる

```python
proc = subprocess.Popen(cmd, shell=True)
```

#### Popen()メソッドでも、終了待ちさせることは可能

```python
proc = subprocess.Popen(cmd,shell=True)
proc.wait()
```

#### Popen()なら、できること

コンソールにプロセス ID を表示する

```python
proc = subprocess.Popen(cmd, shell=True)
print(f'process {proc.pid} starts')
proc.wait()
```

### subprocess.getoutput()

サブプロセスの戻り値を取得できる

```python
from subprocess import getoutput

for color in spec['colors']:
    cmd = f'identify -format "%w,%h" temp/{color["filename"]}'
    size = getoutput(cmd).split(',')
    width = int(size[0])
    height = int(size[1])
```

## 05. 環境変数を使う

### 環境変数にキーバリューペアを追加する

python-dotenv を使う

公式トップ => [https://saurabh-kumar.com/python-dotenv/](https://saurabh-kumar.com/python-dotenv/)

インストール => `pip install python-dotenv`

python-dotenv は、.env ファイルに書いておいたキーバリューペアを環境変数に追加する\
.env ファイルは、`API_KEY=XXXXXXXX`と書く

.env ファイルは、同じフォルダにあるものとする

```python
from dotenv import load_dotenv

load_dotenv()
```

### 環境変数を読み込む

load_dotenv()が実行されるまで、環境変数にはなにも入っていないので要注意\
クラスやファンクションの中に書くことを習慣にすべし

```python
import os

class CVG():
    def __init__(self, env='local'):
        CVG_HOST_NAME = os.environ.get('CVG_HOST_NAME')
        CVG_USER_NAME = os.environ.get('CVG_USER_NAME')
        CVG_PASSWORD = os.environ.get('CVG_PASSWORD')
        CVG_DB_NAME = os.environ.get('CVG_DB_NAME')
```

## 06. ネットワークドライブにローカルドライブを割り当てる

Powershell ではなく、コマンドプロンプトならば、Git Bash の中からでも使用可能

NET USE コマンドの使い方

```bash
# ネットワークドライブの接続を設定する
NET USE X: \\192.168.2.100\公開フォルダ

# ネットワークドライブの一覧を表示する
NET USE

# ネットワークドライブの接続を解除する
NET USE Z: /delete
```

connect_x.bat

```bash
NET USE X: \\192.168.2.100\公開フォルダ
```

script.py

```python
import subprocess

cmd = 'conn_x.bat'
proc = subprocess.Popen(cmd, shell=True)
print(f'process {proc.pid} starts: ネットワークドライブに接続しています')
proc.wait()
```

バッチファイルの中に日本語がある場合は、バッチファイルそのものをシフト JIS で保存すること

## 07. スクリプトに「待たせる」

sleep 関数の引数は秒数

```python
from time import sleep

# 60秒待たせる
sleep(60)
```

## 08. クラス・メソッドを一発で CLI ツールに変換する

Fire を使う

### Fire とは

Python で簡単に CLI ツールを作成するためのライブラリ

公式トップ => [google/python\-fire: Python Fire is a library for automatically generating command line interfaces \(CLIs\) from absolutely any Python object\.](https://github.com/google/python-fire)

インストール => `pip install fire`

マニュアル => [python\-fire/using\-cli\.md at master · google/python\-fire](https://github.com/google/python-fire/blob/master/docs/using-cli.md)

### Fire の使い方 例 1

hello.py

```python
import fire

def hello(name="World"):
  return "Hello %s!" % name

if __name__ == '__main__':
  fire.Fire(hello)
```

hello.py を使う

```bash
python hello.py  # Hello World!
python hello.py --name=David  # Hello David!
python hello.py --help  # Shows usage information.
```

### Fire の使い方 例 2

calculator.py

```python
import fire

class Calculator(object):
  """A simple calculator class."""

  def double(self, number):
    return 2 * number

if __name__ == '__main__':
  fire.Fire(Calculator)
```

calculator.py を使う

```bash
python calculator.py double 10  # 20
python calculator.py double --number=15  # 30
```

クラスを指定すると、複数のメソッドが使えるところがいい
